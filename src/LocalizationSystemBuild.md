<!--
 * @Author: zigfried 3572931733@qq.com
 * @Date: 2023-07-07 16:32:54
 * @LastEditors: zigfried 3572931733@qq.com
 * @LastEditTime: 2023-07-12 10:51:08
 * @FilePath: /localizationProject/src/LocalizationSystemBuild.md
 * @Description: 
 * 
 * Copyright (c) 2023 by zigfried, All Rights Reserved. 
-->
[参考](https://zhuanlan.zhihu.com/p/104791974)
[github](https://github.com/Little-Potato-1990/localization_in_auto_driving)

## 01 模块介绍
`2023-7-7`
1. 3D激光SLAM
包括激光点云地图的建立与基于点云地图的定位。
建图又包括室外大场景建图与室内场景建图，区别是室外大场景必须借助RTK作为约束才能建立精确地图，室内场景由于没有RTK信号，则需要寻找其他约束才能建立闭合地图，比如闭环检测等。

2. 点云地图定位基础上添加 IMU 、GNSS、轮速计等信息
仅依赖激光雷达定位，容易受外界环境影响，比如雷达被遮挡，或者进入了空旷地带，所以需要寻找在特性上和它互补的传感器做融合。

3. 组合导航
此处组合导航是指“IMU+GNSS”的组合（轮速计一般作为附加项供用户选择，此处我们也会介绍相应的融合方法）。理论上，有了“点云地图定位+IMU+GNSS”的融合，就不再需要“IMU+GNSS”的组合导航系统了，此处仍然把它作为一个模块来做，是由自动驾驶的现状决定的，具体来讲就包括这样几个方面：
    - 早期自动驾驶很多借助于组合导航系统来做定位，导致后来转成多传感器融合以后，很多都是购买一套“IMU+GNSS”的导航系统成品，然后再在此基础上加上雷达定位做融合。所以对组合导航的原理和具体实现做深入了解是很有必要的。
    - 有些场景下的自动驾驶是使用雷达做定位的，所以这时候即使自己开发，能使用的传感器也只是IMU、GNSS、轮速计这些，所以这仍然是组合导航的范畴。

4. 后处理
诺瓦泰的PP7在自动驾驶里的出镜率很高，如果使用过，那么对它的后处理软件“IE”应该也不陌生。后处理这个东西简单来讲就是给融合系统增加了将来视角，它会根据采集的数据对历史时刻的导航结果做修正，这样做的主要目的是在建立地图的时候使用，以对点云的位姿进一步优化，获得更高的地图精度。


## 02 数据集
`2023-7-9`
数据集下载网盘的bag压缩卷：`bag_file00` `bag_file01` `bag_file02` `bag_file03` `bag_file04`
使用命令：`cat bag_file*>bag.tar.gz`可以把压缩卷合成一个文件`bag.tar.gz`
解压后得到`kitti_2011_10_03_drive_0027_synced.bag`是数据时间同步后的kitti数据
然后测试一下数据是否正常
```bash
roscore
rviz -d kitti.rviz
rosbag play kitti_2011_10_03_drive_0027_synced.bag
rosrun tf tf_monitor
```
tf_monitor可以查看tf树的关系
## 03 软件框架
1. 每一类信息的订阅和发布封装成一个类，它的callback做为类内函数存在，这样在node文件中想要订阅这个消息的时候只需要在初始化的时候定义一个类的对象，就可以在正常使用过程中从类内部直接取它的数据了。
2. 每种传感器专门封装了对应的数据结构，在sensor_data文件夹下，目前有imu_data.hpp、gnss_data.hpp、cloud_data.hpp分别对应IMU数据、GNSS数据、点云数据。
3. 这种封装就是为了适应一开始提到的接口功能，同时也可以配合第一步封装的订阅类和发布类使用，把订阅的数据直接封装好再供主程序取，这样封闭性更强。
4. 缓冲区机制：这种机制完全是由于ROS自身的缺陷导致的。这个问题和ROS订阅信息时缓冲区读取有关，ROS在每次循环时，会逐个遍历各个subscriber的缓冲区，并且把缓冲区中的数据读完，不管有多少。我们在subscriber的callback中解析数据的时候，一般都是把数据赋给一个变量，然后在融合的时候使用最后更新的值作为输入。

> 这样看好像没什么问题，问题在于当融合算法处理时间比较长，超出了传感器信息的发送周期的时候，未被接收的数据会被放在每个subscriber对应的缓冲区中，等当前融合步骤处理完之后，下次ros从缓冲区中读取数据的时候，会先把gnss的数据读完，然后再读lidar的数据，这就导致，我们再一次进入lidar_callback函数时，使用的gnss_data已经不是和这个lidar_data同一时刻的数据了，而是它后面时刻的数据。

“会先把gnss的数据读完，然后再读lidar的数据”感觉这句话描述不准确，ros的回调函数队列并没有绝对的先后，各回调函数的数量大概和传感器的频率是对应的。总之，如果不使用缓冲区，每次只取最新的值，很容易出现时间戳对不上的情况，或者说有更接近的时间匹配但是没有用上。

## 04 前端里程计
